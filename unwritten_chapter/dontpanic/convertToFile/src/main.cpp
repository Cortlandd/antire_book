#include <cstdlib>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstring>
#include <elf.h>

uint64_t find_thread_start(const std::string& p_data)
{
    if (p_data[0] != 0x7f || p_data[1] != 'E' || p_data[2] != 'L' || p_data[3] != 'F')
    {
        return 0;
    }

    unsigned int strsize = 0;
    const char* strtab = NULL;
    const Elf64_Sym* symtab = NULL;
    const Elf64_Ehdr* ehdr = reinterpret_cast<const Elf64_Ehdr*>(&p_data[0]);
    const Elf64_Phdr* phdr = reinterpret_cast<const Elf64_Phdr*>(&p_data[ehdr->e_phoff]);
    int ph_entries = ehdr->e_phnum;

    for (int i = 0; i < ph_entries; i++, phdr++)
    {
        if (phdr->p_type == PT_DYNAMIC)
        {
            for (const Elf64_Dyn* dyn = reinterpret_cast<const Elf64_Dyn*>(&p_data[phdr->p_offset]); dyn->d_tag != DT_NULL; ++dyn)
            {
                switch (dyn->d_tag)
                {
                    case DT_STRTAB:
                        strtab = &p_data[dyn->d_un.d_ptr];
                        break;
                    case DT_SYMTAB:
                        symtab = reinterpret_cast<const Elf64_Sym*>(&p_data[dyn->d_un.d_ptr]);
                        break;
                    case DT_STRSZ:
                        strsize = dyn->d_un.d_val;
                        break;
                    default:
                        break;
                }
            }
        }
    }

    if (strtab == NULL || symtab == NULL || strsize == 0)
    {
        return 0;
    }

    // skip the empty first entry
    symtab++;
    for ( ; symtab->st_name < strsize; symtab++)
    {
        if (strcmp(&strtab[symtab->st_name], "thread_start") == 0)
        {
            return symtab->st_value;
        }

        if (symtab->st_info == 0 && symtab->st_name == 0 && symtab->st_other == 0 &&
            symtab->st_shndx == 0 && symtab->st_size == 0 && symtab->st_value == 0)
        {
            return 0;
        }
    }

    return 0;
}

void overwriteHeaders(std::string& p_data)
{
    Elf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(&p_data[0]);
    Elf64_Off ph_offset = ehdr->e_phoff;
    Elf64_Half ph_count = ehdr->e_phnum;

    memset(ehdr, 0, sizeof(Elf64_Ehdr));
    for (int i = 0; i < ph_count; i++)
    {
        memset(&p_data[ph_offset + (sizeof(Elf64_Phdr) * ph_count)], 0, sizeof(Elf64_Phdr));
    }
}

int main(int p_argc, char** p_argv)
{
    if (p_argc != 2)
    {
        std::cerr << "Usage: ./convertToFile <file path>" << std::endl;
        return EXIT_FAILURE;
    }

    std::ifstream inputFile(p_argv[1], std::ifstream::in | std::ifstream::binary);
    if (!inputFile.is_open() || !inputFile.good())
    {
        std::cerr << "Failed to open the provided file: " << p_argv[1] << std::endl;
        return EXIT_FAILURE;
    }

    std::string input((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_iterator<char>());
    inputFile.close();

    int thread_start = find_thread_start(input);
    if (thread_start == 0)
    {
        std::cerr << "\033[0;31m" << p_argv[0] << ": Failed to find thread_start()\033[0m" << std::endl;
        return EXIT_FAILURE;
    }

    // stomp on the ELF header and program headers
    overwriteHeaders(input);

    std::cout << "#ifndef THE_BINARY_H" << std::endl;
    std::cout << "#define THE_BINARY_H" << std::endl;
    std::cout << "// I've been generated by convertToFile!" << std::endl;
    std::cout << "#include <stdint.h>" << std::endl;
    std::cout << std::endl;
    std::cout << "uint64_t s_thread_start = " << thread_start << ";" << std::endl;
    std::cout << "unsigned char the_binary[" << input.length() << "] =" << std::endl;
    std::cout << "{";
    for (std::size_t i = 0; i < input.length(); ++i)
    {
        if ((i % 16) == 0)
        {
            std::cout << std::endl;
            std::cout << "    ";
        }
        else
        {
            std::cout << " ";
        }

        std::cout << "0x" << std::setfill('0') << std::setw(2) << std::hex << static_cast<unsigned int>(input[i] & 0xff);

        if (i != (input.length() - 1))
        {
            std::cout << ",";
        }
    }
    std::cout << std::endl << "};" << std::endl;
    std::cout << "#endif" << std::endl;
    return EXIT_SUCCESS;
}
